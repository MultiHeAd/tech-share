"""



回收机制以引用计数器为主，标记清楚和分代回收为辅助


1.引用计数器：会创造一个refchain环状双向链表
在python中每次创建对象都会加入到refchain里，每一个对象都会包括四个主要内容，分别是 上一个对象，下一个对象，该对象信息（类型/内容），引用计数
在c源码中创建了一个py_object的结构体，每一个结构体都包含上面说的四部分内容
当python程序运行的时候，会根据数据类型的不同找到其对应的结构体，根据结构体中的字段来创建相关的数据，然后将对象添加到refchain双线链表中
在c源码中有两个关键结构体，pyobject和pyvarobject来实现
每个对象中有ob_refcnt就是引用计数器，值变为1，当其他变量有引用的时候，引用计数器就会发生变化。

删除引用
a=999
b=a
del b b对应的的对象引用计数器-1
del a

当一个对象的引用计数器为0，则python内部会对对象进行垃圾回收

回收：从refchain链表移除，将对象销毁，内存归还


2.标记清除

为什么需要标记清除？
如果只用引用计数器会有bug，循环引用的问题
v1 = [1,2]
v2 = [4,5]
v1.append(v2)
v2.append(v1)

del v1
del v2

result:
[1, 2, [4, 5, [...]]]
[4, 5, [1, 2, [...]]]
循环引用导致的内存没有被即使释放：表现为内存满了，程序或者电脑重启后内存恢复正常

实现：
在python的底层再去维护一个链表，链表中专门放那些可能存在循环引用的对象（列表，字典，元组，集合）
所以refchain不变，存储所有对象；新链表存可能发生变化的对象（也加到refchain，因为refchain只是来用来确认计数器的）
在python内部会某种情况下触发，扫描右边的列表中的每个元素，包括子元素，如果存在循环引用，检查是否有循环引用，如果有，则让双方的引用计数器-1，如果是0则被回收

什么情况会扫描呢？扫描代价可能大



3.分代回收
分代回收会把可能存在循环引用的链表分为3个链表：
分别叫0，1，2代链表，每代都是双向链表
0：如果对象达到700个则扫描1次
1：0代扫描10次1代扫描1次
2：1代扫描10次2代扫描1次

4.总结
每个对象都有ob_refcnt这个参数————引用计数器
优化机制：缓存
大体上分成两大类：


池：(int,str)
为了避免重复创建和销毁一些常见对象，维护池
内存提前帮我们创造一个小数据池-5，-4.。。256常用值
使用的时候会直接去池里获取，不用开辟一片新的内存


free_list
当一个对象的引用计数器为0的时候，按理说应该回收，但python内部实际不会去回收，而是将对象添加到free_list缓存，以后再去创建对象的时候不再重新开辟
v1 = 3.14 #开辟内存
del v1   #refchain中移除，按理说应该销毁，实际会将对象添加到free_list，以后再使用这个float对象直接获取上一个对象，初始化值
v9=999.99


"""

# v1 = [1,2]
# v2 = [4,5]
# v1.append(v2)
# v2.append(v1)
#
#
# print(v1)
# print(v2)

# v1 = 243
# v1+=1
# v2 = 243
# v1-=1
# print(id(v1))
# print(id(v2))

# v1 = 3.14 #开辟内存
# print( id(v1) )
# del v1   #refchain中移除，按理说应该销毁，实际会将对象添加到free_list，以后再使用这个float对象直接获取上一个对象，初始化值
# v2 = 9.999
# print( id(v2) )